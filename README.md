# **CoreJava**

---
## **5. 상속 (Inheritance)**

4장에서 클래스와 오브젝트를 소개했다.
이 장에서 당신은 상속에 대하여 학습할 것이고, 객체지향프로그래밍의 또 다른 핵심적인 개념이다.
상속의 개념은 당신이 존재하는 클래스에 의거하여? 새로운 클래스를 생성할 수 있다.
너가 존재하는 클래스로부터 상속받을 때, 당신은 그것의 메소드를 재사용하고, 당신은  새로운 메소드와 새로운 환경에서 새로운 클래스에 적용된 필드를 추가할 수 있다.
이 기술은 자바 프로그래밍에서 필수적이다.

이 장은 또한 reflection(실행중인 프로그램에서 클래스와 그들의 properties에 대하여 더 알아보는 능력)을 포함한다. Reflection은 강력한 특징이나, 확실히 복잡하다.
reflection이 application프로그래머보다 tool개발자들에게 흥미가 더 큰 이후로, 당신은 아마도 처음 읽었을 때 그 부분을 훑어보고 나중에 다시 볼 수 있을 것이다.

- 5-1 클래스, 부모클래스(Superclass), 자식클래스(Subclass)
    우리가 이전 장에서 다루던 Employee 클래스를 돌아보자.
    당신이 관리자(manager)가 다른 직원(employee)으로 부터 따로 다룬 회사에서 일을 한다고 가정하자.
    물론 관리자는 많은 면에서 마치 직원과 같다.
    직원과 관리자 둘 다 봉급을 받는다.
    그러나 직원이 그들의 봉급을 받는 대가로 할당된 일들을 끝내는 것을 예상되는 반면, 관리자는 만약 그들이 실제로 그들이 하기로 되어있던 것을 달성한다면 bonuses를 받는다.
    이것은 상속을 절실히 바라는 환경의 종류이다.
    왜? 음, 너는 새로운 클래스, Manager, 추가기능을 정의하는 것을 필요로 한다.
    그러나 당신은 Employee클래스에서 이미 프로그램했었던 것들의 일부를 보유?할 수 있다. 그리고 original 클래스의 모든 필드가 보존될 수 있다.
    더 추상적으로, 명백한 Manager와 Employee 사이에 명백한 "is-a" 관계가 있다.
    모든 manager은 하나의 employee : 이 "is-a" 관계는 상속의 특징이다.

    ```
    필기 : 이 장에서, 우리는 employees와 managers 전형적인 예시를 사용하나, 우리는 당신에게 이 예를 에누리하여 들어줄 것을 요청해야 한다.
    현실세계에서 직원은 관리자가 될 수 있다. 그래서 당신은 직원의 한 역할로서 관리자가 되는 모델을 원할것이다. 하나의 자식클래스가 아니라.
    그러나, 우리의 예시에서 우리는 두 종류의 사람에 의해 설립된 기업?법인?세계를 추정한다:영원히 직원인 사람들, 그리고 항상 관리자가 될 지도 모르는 사람들
    ```

    - 5-1-1 자식클래스 정의
        당신이 Employee클래스로부터 상속받은 Manager클래스를 정의하는 방법이 있다.
        상속을 의미하는 *extends* 자바 키워드를 사용해라.
        
        ```
        public class Manager extends Employee
        {
            // added methods and fields
        }
        ```
        
        ```
        C++ 필기 : 상속은 자바와 C++에서 비슷하다.
        자바는 : 토큰 대신에 extends 키워드를 사용한다.
        자바에서 모든 상속은 public 상속이다; private과 protected 상속의 C++특징에서 유사성이 없다.
        ```

        extends 키워드는 당신이 existing 클래스에서 파생된 새로운 클래스를 생성한다는 것을 나타낸다.
        existing 클래스는 superclass, base class, parent class 라고 불린다.
        새로운 클래스는 subclass, derived class, child class 라고 불린다.
        슈퍼클래스와 서브클래스의 표현?용어?는 자바 프로그래머에 의해 가장 흔히 사용된다, 비록 몇몇 프로그래머들이 부모/자식 유사성?유추?을 선호하지만,
        이것은 또한 "상속" 주제와 함께 병행한다.

        Employee 클래스는 슈퍼클래스이다. 그러나, 그것이 서브클래스보다 우월하기 때문에 또는 더 많은 기능을 포함하고 있기 때문은 아니다.
        사실, 그 반대는 사실이다 : 서브클래스는 슈퍼클래스보다 더 많은 기능을 가지고 있다.
        예를 들면, 우리가 Manager클래스 코드의 나머지 부분을 살펴보면 알 수 있듯이, Manager 클래스는 슈퍼클래스 Employee 보다 더 많은 정보를 요약화하고, 더 많은 기능을 가진다.

        ```
        필기 : 접두사 super와 sub는 이론상으로 컴퓨터 과학과 수학에서 사용되는 집합의 언어로부터 유래한다.
        모든 employees 집합은 모든 managers 집합을 포함하므로, managers 집합의 superset 이라고 한다.
        또는, 다르게 말하면, 모든 managers 집합은 모든 employees 집합의 subset 이다.
        ```

        우리의 Manager 클래스는 bonus를 저장하는 새로운 필드를 가지고 있고, 이것을 설정하는 새로운 메소드를 가지고 있다.

        ```
        public class Manager extends Employee
        {
            private double bonus;
            ...
            public void setBonus(double bonus)
            {
                this.bonus = bonus;
            }
        }
        ```

        이 메소드와 필드에 대하여 특별한 것이 없다.
        만약 당신이 Manager 객체를 가지고 있다면, 당신은 간단하게 setBonus 메소드를 적용할 수 있다.

        ```
        Manager boss = ...;
        boss.setBonus(5000);
        ```

        물론, 만약 당신이 Employee 객체를 가지고 있다면, 당신은 setBonus 메소드를 적용할 수 없다. - Employee 클래스에서 정의된 메소드가 아니다.